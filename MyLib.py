'''
# The code below does not seem to work as intended
import sys
modulename = 'numpy'
if modulename not in sys.modules:
    print('You have not imported the {} module'.format(modulename))
'''
import numpy
import pandas

def MyTriangularNumber(n):
    return (n*(n+1))/2

def MyInvTriangularNumber(n):
    return int(-0.5+numpy.sqrt(2*n+1/4))

def MyFun(X, Y):
    return 2*X**2-0.5*Y**3+0.01*X**6*Y-X**4*Y**2

def GeneralFunction(c, X, Y):
    t1 = c[1]*X
    t2 = c[2]*Y
    t3 = c[3]*X*Y
    t4 = c[4]*X**2
    t5 = c[5]*Y**2
    result = c[0] + t1 + t2 + t3 + t4 + t5
    return result

#fixme: This can probably be solved much prettier by returning a function taking c as an argument
# instead of returning a numerical value.
# The solution is ugly(?) but it seems to work.
def GeneralPolynomial(c, X, Y):
    result = numpy.zeros(X.shape)
    n = c.__len__()
    d = MyInvTriangularNumber(n)
    k = 0
    for i in range(d):
        if i == 0:
            result += c[k]
            k += 1
        else:
            for j in range(i):
                result += c[k]*X**j*Y**(i-j)
                k += 1
    return result


def SampleData(X, Y, Z, n):
    '''
    :param X:
    Meshgrid in x
    :param Y:
    Meshgrid in y
    :param Z:
    Scalar field generated by a 2 dimensional function
    :param n:
    Number of data points in the returned data set
    :return:
    A pandas dataframe from the generated data that will be fitted against
    '''
    shape = Z.shape
    #fixme: The x and y's can probably be removed somehow making the code cleaner
    randIndexX = [numpy.random.randint(0, shape[0]) for x in range(n)]
    randIndexY = [numpy.random.randint(0, shape[1]) for y in range(n)]

    x = X[randIndexX, randIndexY]
    y = Y[randIndexX, randIndexY]
    z = Z[randIndexX, randIndexY]

    data = numpy.array([x,y,z]).transpose()
    df = pandas.DataFrame(data, columns=['x', 'y', 'z'])

    return df